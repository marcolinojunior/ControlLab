"""
M√≥dulo Principal de An√°lise de Estabilidade
============================================

Este m√≥dulo integra todos os m√©todos de an√°lise de estabilidade,
fornecendo uma interface unificada e pedag√≥gica para:

- An√°lise de estabilidade usando crit√©rio de Routh-Hurwitz
- An√°lise do lugar geom√©trico das ra√≠zes (Root Locus)
- An√°lise de resposta em frequ√™ncia e margens de estabilidade
- Valida√ß√£o cruzada entre m√©todos
- An√°lise param√©trica e regi√µes de estabilidade

Classes Principais:
    StabilityAnalysisEngine: Interface unificada de an√°lise
    ComprehensiveStabilityReport: Relat√≥rio pedag√≥gico completo

Exemplo de Uso:
    ```python
    from controllab.analysis.stability_analysis import StabilityAnalysisEngine

    # Criar fun√ß√£o de transfer√™ncia
    s = sp.Symbol('s')
    tf = (s + 1) / (s**3 + 2*s**2 + 3*s + 1)

    # An√°lise completa
    engine = StabilityAnalysisEngine()
    result = engine.comprehensive_analysis(tf, show_all_steps=True)

    # Visualizar relat√≥rio
    print(result.get_full_report())
    ```
"""

import sympy as sp
from sympy import symbols, solve, simplify, expand, factor, collect
from typing import Dict, List, Tuple, Any, Optional, Union
import warnings

# Importar m√≥dulos de an√°lise
try:
    import sys
    import os

    # Configurar path se executado diretamente
    if __name__ == "__main__":
        current_dir = os.path.dirname(os.path.abspath(__file__))
        project_root = os.path.dirname(os.path.dirname(os.path.dirname(current_dir)))
        src_path = os.path.join(project_root, 'src')
        if src_path not in sys.path:
            sys.path.insert(0, src_path)

    from controllab.analysis.routh_hurwitz import RouthHurwitzAnalyzer, StabilityResult
    from controllab.analysis.root_locus import RootLocusAnalyzer
    from controllab.analysis.frequency_response import calculate_gain_phase_margins, apply_nyquist_criterion
    from controllab.analysis.stability_utils import (StabilityValidator, ParametricAnalyzer,
                                 ValidationHistory, format_stability_report)
    from controllab.analysis.pedagogical_formatter import format_routh_hurwitz_response, format_root_locus_response, format_bode_response, format_nyquist_response
except ImportError as e:
    print(f"Aviso: Alguns m√≥dulos de an√°lise n√£o est√£o dispon√≠veis: {e}")
    print("Tentando imports alternativos...")

    # Tentar imports alternativos para teste direto
    try:
        from routh_hurwitz import RouthHurwitzAnalyzer, StabilityResult
        from root_locus import RootLocusAnalyzer
        from frequency_response import FrequencyAnalyzer, StabilityMargins
        from stability_utils import (StabilityValidator, ParametricAnalyzer,
                                     ValidationHistory, format_stability_report)
        from pedagogical_formatter import format_routh_hurwitz_response, format_root_locus_response
        print("Imports alternativos bem-sucedidos!")
    except ImportError:
        warnings.warn(f"Alguns m√≥dulos de an√°lise n√£o est√£o dispon√≠veis: {e}")
        # Definir classes vazias como fallback
        RouthHurwitzAnalyzer = None
        RootLocusAnalyzer = None
        FrequencyAnalyzer = None
        StabilityValidator = None
        ParametricAnalyzer = None


class ComprehensiveStabilityReport:
    """
    Relat√≥rio pedag√≥gico completo de an√°lise de estabilidade

    Esta classe organiza todos os resultados de an√°lise em um formato
    educacional, mostrando conex√µes entre m√©todos e explica√ß√µes detalhadas.
    """

    def __init__(self):
        self.system_info = {}
        self.routh_hurwitz_results = None
        self.root_locus_results = None
        self.bode_results = None
        self.nyquist_results = None
        self.frequency_response_results = None
        self.validation_results = None
        self.parametric_results = None
        self.conclusions = []
        self.educational_notes = []

    def add_system_info(self, tf_obj, description: str = ""):
        """Adiciona informa√ß√µes do sistema"""
        try:
            if hasattr(tf_obj, 'numerator') and hasattr(tf_obj, 'denominator'):
                num = tf_obj.numerator
                den = tf_obj.denominator
                var = tf_obj.variable if hasattr(tf_obj, 'variable') else 's'
            else:
                num = sp.numer(tf_obj)
                den = sp.denom(tf_obj)
                var = list(tf_obj.free_symbols)[0] if tf_obj.free_symbols else 's'

            self.system_info = {
                'transfer_function': tf_obj,
                'numerator': num,
                'denominator': den,
                'variable': var,
                'order': sp.degree(den, var),
                'description': description,
                'characteristic_polynomial': den
            }

        except Exception as e:
            self.system_info = {'error': f"Erro ao processar sistema: {e}"}

    def add_educational_note(self, category: str, note: str):
        """Adiciona nota educacional"""
        self.educational_notes.append({
            'category': category,
            'note': note
        })

    def add_analysis_report(self, method: str, report: dict):
        """Adiciona um relat√≥rio de an√°lise."""
        if method == 'Routh-Hurwitz':
            self.routh_hurwitz_results = report
        elif method == 'Root Locus':
            self.root_locus_results = report
        elif method == 'Bode':
            self.bode_results = report
        elif method == 'Nyquist':
            self.nyquist_results = report

    def add_conclusion(self, method: str, conclusion: str, confidence: str = "Alta"):
        """Adiciona conclus√£o de m√©todo"""
        self.conclusions.append({
            'method': method,
            'conclusion': conclusion,
            'confidence': confidence
        })

    def get_executive_summary(self) -> str:
        """Retorna resumo executivo da an√°lise"""
        summary = "üéØ RESUMO EXECUTIVO - AN√ÅLISE DE ESTABILIDADE\n"
        summary += "=" * 50 + "\n\n"

        if self.system_info and 'order' in self.system_info:
            summary += f"üìã SISTEMA: Ordem {self.system_info['order']}\n"
            tf_str = str(self.system_info.get('transfer_function', 'N/A'))
            summary += f"üìê FUN√á√ÉO DE TRANSFER√äNCIA: {tf_str}\n\n"

        # Compilar conclus√µes
        stable_methods = []
        unstable_methods = []
        uncertain_methods = []

        for conclusion in self.conclusions:
            if 'est√°vel' in conclusion['conclusion'].lower():
                stable_methods.append(conclusion['method'])
            elif 'inst√°vel' in conclusion['conclusion'].lower():
                unstable_methods.append(conclusion['method'])
            else:
                uncertain_methods.append(conclusion['method'])

        total_methods = len(self.conclusions)
        if total_methods > 0:
            summary += f"‚úÖ M√âTODOS INDICANDO ESTABILIDADE: {len(stable_methods)}/{total_methods}\n"
            if stable_methods:
                summary += f"   {', '.join(stable_methods)}\n"

            summary += f"‚ùå M√âTODOS INDICANDO INSTABILIDADE: {len(unstable_methods)}/{total_methods}\n"
            if unstable_methods:
                summary += f"   {', '.join(unstable_methods)}\n"

            if uncertain_methods:
                summary += f"‚ùì M√âTODOS INCONCLUSIVOS: {len(uncertain_methods)}/{total_methods}\n"
                summary += f"   {', '.join(uncertain_methods)}\n"

        # Conclus√£o final
        summary += "\nüèÅ CONCLUS√ÉO FINAL: "
        if len(stable_methods) > len(unstable_methods):
            summary += "SISTEMA EST√ÅVEL\n"
        elif len(unstable_methods) > len(stable_methods):
            summary += "SISTEMA INST√ÅVEL\n"
        else:
            summary += "AN√ÅLISE INCONCLUSIVA - NECESS√ÅRIO MAIS INVESTIGA√á√ÉO\n"

        return summary

    def get_detailed_analysis(self) -> str:
        """Retorna an√°lise detalhada por m√©todo"""
        analysis = "üìä AN√ÅLISE DETALHADA POR M√âTODO\n"
        analysis += "=" * 40 + "\n\n"

        # Routh-Hurwitz
        if self.routh_hurwitz_results:
            analysis += "üî¢ AN√ÅLISE DE ROUTH-HURWITZ:\n"
            analysis += "-" * 30 + "\n"
            try:
                if hasattr(self.routh_hurwitz_results, 'get_formatted_history'):
                    analysis += self.routh_hurwitz_results.get_formatted_history()
                else:
                    analysis += str(self.routh_hurwitz_results)
            except Exception as e:
                analysis += f"Erro na formata√ß√£o: {e}"
            analysis += "\n\n"

        # Root Locus
        if self.root_locus_results:
            analysis += "üìç AN√ÅLISE DO LUGAR GEOM√âTRICO:\n"
            analysis += "-" * 35 + "\n"
            try:
                if hasattr(self.root_locus_results, 'analysis_history') and self.root_locus_results.analysis_history:
                    analysis += self.root_locus_results.analysis_history.get_formatted_report()
                else:
                    analysis += str(self.root_locus_results)
            except Exception as e:
                analysis += f"Erro na formata√ß√£o: {e}"
            analysis += "\n\n"

        # Frequency Response
        if self.frequency_response_results:
            analysis += "üìà AN√ÅLISE DE RESPOSTA EM FREQU√äNCIA:\n"
            analysis += "-" * 40 + "\n"
            try:
                if hasattr(self.frequency_response_results, 'get_formatted_history'):
                    analysis += self.frequency_response_results.get_formatted_history()
                else:
                    analysis += str(self.frequency_response_results)
            except Exception as e:
                analysis += f"Erro na formata√ß√£o: {e}"
            analysis += "\n\n"

        return analysis

    def get_educational_section(self) -> str:
        """Retorna se√ß√£o educacional com explica√ß√µes"""
        education = "üéì SE√á√ÉO EDUCACIONAL\n"
        education += "=" * 25 + "\n\n"

        education += "üìö CONCEITOS FUNDAMENTAIS:\n"
        education += "‚Ä¢ ESTABILIDADE: Um sistema √© est√°vel se suas sa√≠das permanecem limitadas\n"
        education += "  para entradas limitadas (BIBO - Bounded Input, Bounded Output)\n"
        education += "‚Ä¢ POLIN√îMIO CARACTER√çSTICO: Determinante da equa√ß√£o caracter√≠stica\n"
        education += "  onde se encontram os polos do sistema\n"
        education += "‚Ä¢ POLOS: Valores de 's' que tornam o denominador zero\n"
        education += "‚Ä¢ INTERPRETA√á√ÉO F√çSICA: Polos no lado esquerdo ‚Üí est√°vel,\n"
        education += "  polos no lado direito ‚Üí inst√°vel, polos no eixo jœâ ‚Üí marginalmente est√°vel\n\n"

        education += "üìö CONEX√ïES ENTRE M√âTODOS:\n"
        education += "‚Ä¢ ROUTH-HURWITZ: M√©todo alg√©brico que analisa sinais na primeira coluna\n"
        education += "  da tabela de Routh para determinar polos no semiplano direito\n"
        education += "‚Ä¢ ROOT LOCUS: M√©todo geom√©trico que mostra o lugar geom√©trico das ra√≠zes\n"
        education += "  no plano complexo conforme o ganho K varia\n"
        education += "‚Ä¢ RESPOSTA EM FREQU√äNCIA: Avalia margens de ganho e fase para\n"
        education += "  determinar robustez do sistema em malha fechada\n\n"

        education += "üîß F√ìRMULAS E EQUA√á√ïES CHAVE:\n"
        education += "‚Ä¢ Equa√ß√£o caracter√≠stica: 1 + G(s)H(s) = 0\n"
        education += "‚Ä¢ Crit√©rio de Routh: Mudan√ßas de sinal = n√∫mero de polos inst√°veis\n"
        education += "‚Ä¢ Margem de ganho (dB) = 20*log10(1/|G(jœâc)|)\n"
        education += "‚Ä¢ Margem de fase (¬∞) = 180¬∞ + ‚à†G(jœâg)\n\n"

        if self.educational_notes:
            education += "üí° NOTAS EDUCACIONAIS ESPEC√çFICAS:\n"
            for note in self.educational_notes:
                education += f"‚Ä¢ {note['category']}: {note['note']}\n"
            education += "\n"

        # Casos especiais e interpreta√ß√£o f√≠sica
        education += "‚ö†Ô∏è CASOS ESPECIAIS IMPORTANTES:\n"
        education += "‚Ä¢ Zero na primeira coluna do Routh: Substituir por Œµ pequeno\n"
        education += "‚Ä¢ Linha de zeros: Usar derivada do polin√¥mio auxiliar\n"
        education += "‚Ä¢ Polos no eixo jœâ: Sistema marginalmente est√°vel\n"
        education += "‚Ä¢ M√∫ltiplos polos: Podem causar instabilidade mesmo no lado esquerdo\n\n"

        # Adicionar explica√ß√µes contextuais baseadas nos resultados
        if self.system_info and 'order' in self.system_info:
            order = self.system_info['order']
            education += f"üîç AN√ÅLISE ESPEC√çFICA PARA SISTEMA DE ORDEM {order}:\n"

            if order == 1:
                education += "‚Ä¢ Sistema de 1¬™ ordem: s + a = 0 ‚Üí Polo em s = -a\n"
                education += "‚Ä¢ INTERPRETA√á√ÉO F√çSICA: Est√°vel se a > 0 (constante de tempo positiva)\n"
                education += "‚Ä¢ Resposta exponencial decrescente para a > 0\n"
            elif order == 2:
                education += "‚Ä¢ Sistema de 2¬™ ordem: s¬≤ + 2Œ∂œâ‚Çôs + œâ‚Çô¬≤ = 0\n"
                education += "‚Ä¢ INTERPRETA√á√ÉO F√çSICA: Œ∂ = coeficiente de amortecimento\n"
                education += "‚Ä¢ Œ∂ < 1: subamortecido, Œ∂ = 1: criticamente amortecido, Œ∂ > 1: superamortecido\n"
                education += "‚Ä¢ Est√°vel se Œ∂ > 0 e œâ‚Çô > 0\n"
            elif order >= 3:
                education += "‚Ä¢ Sistema de ordem superior: An√°lise complexa necess√°ria\n"
                education += "‚Ä¢ INTERPRETA√á√ÉO F√çSICA: M√∫ltiplos modos de resposta\n"
                education += "‚Ä¢ Routh-Hurwitz √© essencial para determinar estabilidade\n"
                education += "‚Ä¢ Root locus mostra como polos se movem com varia√ß√£o de ganho\n"

            education += "\n"

        education += "üéØ SIGNIFICADO PR√ÅTICO DA ESTABILIDADE:\n"
        education += "‚Ä¢ Sistema EST√ÅVEL: Perturba√ß√µes se atenuam com o tempo\n"
        education += "‚Ä¢ Sistema INST√ÅVEL: Perturba√ß√µes crescem indefinidamente\n"
        education += "‚Ä¢ Sistema MARGINAL: Perturba√ß√µes n√£o se atenuam nem crescem\n"
        education += "‚Ä¢ APLICA√á√ÉO: Fundamental para seguran√ßa e performance de sistemas\n\n"

        return education

    def get_full_report(self) -> str:
        """Retorna relat√≥rio completo"""
        report = "üìã RELAT√ìRIO COMPLETO DE AN√ÅLISE DE ESTABILIDADE\n"
        report += "=" * 60 + "\n\n"

        report += self.get_executive_summary() + "\n"
        report += self.get_detailed_analysis() + "\n"
        report += self.get_educational_section() + "\n"

        if self.validation_results:
            report += "üîç VALIDA√á√ÉO CRUZADA:\n"
            report += "-" * 20 + "\n"
            if hasattr(self.validation_results, 'get_formatted_report'):
                report += self.validation_results.get_formatted_report()
            else:
                report += str(self.validation_results)
            report += "\n\n"

        return report

    def get_cross_validation_report(self) -> str:
        """Retorna relat√≥rio de valida√ß√£o cruzada"""
        if not self.validation_results:
            return "‚ùå Valida√ß√£o cruzada n√£o realizada"

        validation_report = "üîç RELAT√ìRIO DE VALIDA√á√ÉO CRUZADA\n"
        validation_report += "=" * 40 + "\n\n"

        # Simular valida√ß√£o cruzada b√°sica
        methods_results = []

        if self.routh_hurwitz_results:
            routh_stable = getattr(self.routh_hurwitz_results, 'is_stable', None)
            methods_results.append(("Routh-Hurwitz", routh_stable))

        if self.root_locus_results:
            # Determinar estabilidade por root locus (polos no lado esquerdo)
            rl_stable = self.root_locus_results.stability_assessment.get('is_stable', None)
            methods_results.append(("Root Locus", rl_stable))

        if self.frequency_response_results:
            freq_stable = getattr(self.frequency_response_results, 'is_stable', True)
            methods_results.append(("Frequency Response", freq_stable))

        # Comparar resultados
        validation_report += "üìä RESULTADOS POR M√âTODO:\n"
        for method, stable in methods_results:
            stability_text = "EST√ÅVEL" if stable else "INST√ÅVEL" if stable is False else "INDETERMINADO"
            validation_report += f"   {method}: {stability_text}\n"

        # Verificar concord√¢ncia
        stable_results = [r[1] for r in methods_results if r[1] is not None]
        if len(set(stable_results)) == 1:
            validation_report += "\n‚úÖ TODOS OS M√âTODOS CONCORDAM\n"
            validation_report += f"   Conclus√£o: Sistema {'EST√ÅVEL' if stable_results[0] else 'INST√ÅVEL'}\n"
        else:
            validation_report += "\n‚ö†Ô∏è DISCREP√ÇNCIAS DETECTADAS\n"
            validation_report += "   An√°lise adicional recomendada\n"

        validation_report += "\nüìö NOTA PEDAG√ìGICA:\n"
        validation_report += "   A valida√ß√£o cruzada √© fundamental para confirmar resultados\n"
        validation_report += "   Pequenas discrep√¢ncias podem indicar casos especiais\n"

        return validation_report


class StabilityAnalysisEngine:
    """
    Motor principal de an√°lise de estabilidade

    Esta classe coordena todos os m√≥dulos de an√°lise, fornecendo
    uma interface unificada para an√°lise completa de estabilidade.
    """

    def __init__(self):
        self.routh_analyzer = RouthHurwitzAnalyzer() if RouthHurwitzAnalyzer else None
        self.root_locus_analyzer = RootLocusAnalyzer() if RootLocusAnalyzer else None
        self.validator = StabilityValidator() if StabilityValidator else None
        self.parametric_analyzer = ParametricAnalyzer() if ParametricAnalyzer else None

    def comprehensive_analysis(self, tf_obj, show_all_steps: bool = True,
                             include_validation: bool = True,
                             include_parametric: bool = False) -> ComprehensiveStabilityReport:
        """
        Realiza an√°lise completa de estabilidade

        Args:
            tf_obj: Fun√ß√£o de transfer√™ncia ou polin√¥mio caracter√≠stico
            show_all_steps: Se deve mostrar todos os passos
            include_validation: Se deve incluir valida√ß√£o cruzada
            include_parametric: Se deve incluir an√°lise param√©trica

        Returns:
            ComprehensiveStabilityReport com todos os resultados
        """
        report = ComprehensiveStabilityReport()

        # Adicionar informa√ß√µes do sistema
        report.add_system_info(tf_obj, "Sistema sob an√°lise")

        # 1. An√°lise de Routh-Hurwitz
        if self.routh_analyzer:
            try:
                char_poly = self._extract_characteristic_polynomial(tf_obj)
                routh_array = self.routh_analyzer.build_routh_array(char_poly, show_steps=show_all_steps)
                routh_result = self.routh_analyzer.analyze_stability(routh_array, show_steps=show_all_steps)

                report.routh_hurwitz_results = routh_result
                conclusion = "Sistema est√°vel" if routh_result.is_stable else "Sistema inst√°vel"
                report.add_conclusion("Routh-Hurwitz", conclusion)

                if show_all_steps:
                    report.add_educational_note("Routh-Hurwitz",
                        "M√©todo alg√©brico que analisa estabilidade sem calcular ra√≠zes explicitamente")

            except Exception as e:
                report.add_conclusion("Routh-Hurwitz", f"Erro na an√°lise: {e}", "Baixa")

        # 2. An√°lise do Root Locus
        if self.root_locus_analyzer:
            try:
                features = self.root_locus_analyzer.analyze_comprehensive(tf_obj, show_steps=show_all_steps)
                report.root_locus_results = features

                is_stable = features.stability_assessment.get('is_stable')
                conclusion = "Sistema est√°vel" if is_stable else "Sistema inst√°vel" if is_stable is False else "An√°lise de estabilidade do Root Locus inconclusiva"
                report.add_conclusion("Root Locus", conclusion)

                if show_all_steps:
                    report.add_educational_note("Root Locus",
                        "M√©todo gr√°fico que mostra como polos se movem com varia√ß√£o de ganho")

            except Exception as e:
                report.add_conclusion("Root Locus", f"Erro na an√°lise: {e}", "Baixa")

        # 3. An√°lise de Resposta em Frequ√™ncia
        if calculate_gain_phase_margins and format_bode_response and apply_nyquist_criterion and format_nyquist_response:
            try:
                # Bode
                margins, history = calculate_gain_phase_margins(tf_obj)
                pedagogical_report = format_bode_response(margins, history)
                report.frequency_response_results = pedagogical_report

                conclusion = "Sistema est√°vel" if margins.is_stable else "Sistema inst√°vel"
                if margins.is_stable:
                    conclusion += f" (MG: {margins.gain_margin_db:.1f}dB, MF: {margins.phase_margin:.1f}¬∞)"

                report.add_conclusion("Margens de Estabilidade", conclusion)

                # Nyquist
                nyquist_results, history = apply_nyquist_criterion(tf_obj)
                pedagogical_report = format_nyquist_response(nyquist_results, history)
                report.add_analysis_report('Nyquist', pedagogical_report)

                conclusion = "Sistema est√°vel" if nyquist_results['is_stable'] else "Sistema inst√°vel"
                report.add_conclusion("Crit√©rio de Nyquist", conclusion)

                if show_all_steps:
                    report.add_educational_note("Margens",
                        "An√°lise de robustez baseada em margens de ganho e fase")

            except Exception as e:
                report.add_conclusion("Margens", f"Erro na an√°lise: {e}", "Baixa")

        # 4. Valida√ß√£o Cruzada
        if include_validation and self.validator:
            try:
                validation_results = self.validator.validate_stability_methods(tf_obj, show_steps=show_all_steps)
                report.validation_results = self.validator.history

                if show_all_steps:
                    report.add_educational_note("Valida√ß√£o",
                        "Compara√ß√£o entre m√©todos para verificar consist√™ncia dos resultados")

            except Exception as e:
                report.add_educational_note("Valida√ß√£o", f"Erro na valida√ß√£o: {e}")

        # 5. An√°lise Param√©trica (opcional)
        if include_parametric and self.parametric_analyzer:
            try:
                # Implementar an√°lise param√©trica se par√¢metros estiverem presentes
                params = self._extract_parameters(tf_obj)
                if len(params) >= 1:
                    # An√°lise de sensibilidade b√°sica
                    param_results = self._basic_parametric_analysis(tf_obj, params)
                    report.parametric_results = param_results

                    report.add_educational_note("Param√©trica",
                        "An√°lise de como varia√ß√µes param√©tricas afetam estabilidade")

            except Exception as e:
                report.add_educational_note("Param√©trica", f"Erro na an√°lise: {e}")

        return report

    def analyze_complete_stability(self, tf_obj, show_steps: bool = True) -> ComprehensiveStabilityReport:
        """
        Alias para comprehensive_analysis para compatibilidade com testes

        Args:
            tf_obj: Fun√ß√£o de transfer√™ncia
            show_steps: Se deve mostrar os passos

        Returns:
            ComprehensiveStabilityReport com an√°lise completa
        """
        report = ComprehensiveStabilityReport()

        # Adicionar informa√ß√µes do sistema
        report.add_system_info(tf_obj, "Sistema sob an√°lise")

        # 1. An√°lise de Routh-Hurwitz
        if self.routh_analyzer:
            try:
                char_poly = self._extract_characteristic_polynomial(tf_obj)
                stability_result, history, polynomial = self.routh_analyzer.analyze(char_poly)
                pedagogical_report = format_routh_hurwitz_response(stability_result, history, polynomial)
                report.add_analysis_report('Routh-Hurwitz', pedagogical_report)
                conclusion = "Sistema est√°vel" if stability_result.is_stable else "Sistema inst√°vel"
                report.add_conclusion("Routh-Hurwitz", conclusion)

                if show_all_steps:
                    report.add_educational_note("Routh-Hurwitz",
                        "M√©todo alg√©brico que analisa estabilidade sem calcular ra√≠zes explicitamente")

            except Exception as e:
                report.add_conclusion("Routh-Hurwitz", f"Erro na an√°lise: {e}", "Baixa")

        return report

    def _extract_characteristic_polynomial(self, tf_obj):
        """Extrai polin√¥mio caracter√≠stico da fun√ß√£o de transfer√™ncia"""
        if hasattr(tf_obj, 'denominator'):
            return tf_obj.denominator
        else:
            return sp.denom(tf_obj)

    def _extract_parameters(self, tf_obj):
        """Extrai par√¢metros simb√≥licos do sistema"""
        if hasattr(tf_obj, 'free_symbols'):
            symbols = list(tf_obj.free_symbols)
        else:
            symbols = []

        # Filtrar s√≠mbolos que provavelmente s√£o vari√°veis (s, z) vs par√¢metros
        parameters = [sym for sym in symbols if str(sym) not in ['s', 'z', 't']]
        return parameters

    def _basic_parametric_analysis(self, tf_obj, parameters):
        """An√°lise param√©trica b√°sica"""
        results = {
            'parameters_found': [str(p) for p in parameters],
            'analysis_type': 'sensitivity',
            'notes': 'An√°lise b√°sica de sensibilidade param√©trica'
        }

        return results

    def quick_stability_check(self, tf_obj) -> Dict[str, Any]:
        """
        Verifica√ß√£o r√°pida de estabilidade usando m√©todo mais eficiente

        Returns:
            Dict com resultado r√°pido
        """
        result = {
            'is_stable': None,
            'method_used': None,
            'confidence': 'Medium',
            'details': {}
        }

        try:
            # Tentar Routh-Hurwitz primeiro (mais eficiente)
            if self.routh_analyzer:
                char_poly = self._extract_characteristic_polynomial(tf_obj)
                routh_array = self.routh_analyzer.build_routh_array(char_poly, show_steps=False)
                routh_result = self.routh_analyzer.analyze_stability(routh_array, show_steps=False)

                result['is_stable'] = routh_result.is_stable
                result['method_used'] = 'Routh-Hurwitz'
                result['details'] = {
                    'unstable_poles_in_rhp': routh_result.unstable_poles_count
                }
                result['confidence'] = 'High'

            # Fallback: c√°lculo direto de polos
            elif self.validator:
                poles = self.validator._calculate_poles_directly(tf_obj)
                is_stable = self.validator._analyze_poles_stability(poles)

                result['is_stable'] = is_stable
                result['method_used'] = 'Direct Pole Calculation'
                result['details'] = {
                    'poles': poles,
                    'unstable_count': sum(1 for p in poles if p.real > 0)
                }

        except Exception as e:
            result['method_used'] = 'Error'
            result['details'] = {'error': str(e)}
            result['confidence'] = 'Low'

        return result

    def comparative_analysis(self, systems: List[Any],
                           labels: List[str] = None) -> Dict[str, Any]:
        """
        An√°lise comparativa entre m√∫ltiplos sistemas

        Args:
            systems: Lista de fun√ß√µes de transfer√™ncia
            labels: Labels para os sistemas

        Returns:
            Dict com an√°lise comparativa
        """
        if not labels:
            labels = [f"Sistema {i+1}" for i in range(len(systems))]

        comparison = {
            'systems': {},
            'summary': {},
            'stability_comparison': []
        }

        for i, (system, label) in enumerate(zip(systems, labels)):
            quick_result = self.quick_stability_check(system)
            comparison['systems'][label] = quick_result

            stability_status = "Est√°vel" if quick_result['is_stable'] else "Inst√°vel"
            comparison['stability_comparison'].append({
                'system': label,
                'status': stability_status,
                'method': quick_result['method_used']
            })

        # Resumo estat√≠stico
        stable_count = sum(1 for sys in comparison['systems'].values()
                          if sys['is_stable'] is True)
        total_count = len(systems)

        comparison['summary'] = {
            'total_systems': total_count,
            'stable_systems': stable_count,
            'unstable_systems': total_count - stable_count,
            'stability_rate': stable_count / total_count if total_count > 0 else 0
        }

        return comparison


# Fun√ß√µes de conveni√™ncia para uso direto
def analyze_stability(tf_obj, show_steps: bool = True) -> ComprehensiveStabilityReport:
    """Fun√ß√£o de conveni√™ncia para an√°lise completa"""
    engine = StabilityAnalysisEngine()
    return engine.comprehensive_analysis(tf_obj, show_all_steps=show_steps)


def quick_stability_check(tf_obj) -> bool:
    """Fun√ß√£o de conveni√™ncia para verifica√ß√£o r√°pida"""
    engine = StabilityAnalysisEngine()
    result = engine.quick_stability_check(tf_obj)
    return result.get('is_stable', False)


def compare_systems_stability(systems: List[Any], labels: List[str] = None) -> Dict:
    """Fun√ß√£o de conveni√™ncia para compara√ß√£o de sistemas"""
    engine = StabilityAnalysisEngine()
    return engine.comparative_analysis(systems, labels)


# ============================================================================
# SE√á√ÉO DE TESTE E VALIDA√á√ÉO
# ============================================================================
def validate_stability_methods(tf_obj, show_steps=True):
    """
    Fun√ß√£o de valida√ß√£o cruzada que retorna um dicion√°rio simples
    para ser usado nos testes.
    """
    engine = StabilityAnalysisEngine()
    report = engine.comprehensive_analysis(tf_obj, show_all_steps=show_steps)

    results = {}

    # Routh-Hurwitz
    if report.routh_hurwitz_results:
        results['routh_hurwitz'] = report.routh_hurwitz_results

    # Root Locus
    if report.root_locus_results and hasattr(report.root_locus_results, 'stability_assessment'):
        is_stable = report.root_locus_results.stability_assessment.get('is_stable')
        results['root_analysis'] = {'is_stable': is_stable}

    # Frequency Analysis
    if report.frequency_response_results:
        results['frequency_analysis'] = report.frequency_response_results

    return results

def run_module_validation():
    """
    Executa valida√ß√£o completa do M√≥dulo 5 - An√°lise de Estabilidade

    Esta fun√ß√£o testa todos os componentes do m√≥dulo e verifica se est√£o
    funcionando corretamente, incluindo pedagogia e integra√ß√£o.
    """
    print("=" * 70)
    print("VALIDA√á√ÉO COMPLETA DO M√ìDULO 5 - AN√ÅLISE DE ESTABILIDADE")
    print("=" * 70)

    import sympy as sp
    s = sp.symbols('s')

    # Definir sistemas de teste
    systems = {
        'Sistema Est√°vel de 1¬™ Ordem': 1 / (s + 1),
        'Sistema Est√°vel de 2¬™ Ordem': 1 / (s**2 + 2*s + 1),
        'Sistema Inst√°vel': 1 / (s**2 - s + 1),
        'Sistema de 3¬™ Ordem': 1 / (s**3 + 3*s**2 + 3*s + 1)
    }

    validation_results = []

    print("\n1. TESTANDO IMPORTA√á√ïES DOS M√ìDULOS...")
    print("-" * 50)

    # Teste de importa√ß√µes
    modules_status = {
        'RouthHurwitzAnalyzer': RouthHurwitzAnalyzer is not None,
        'RootLocusAnalyzer': RootLocusAnalyzer is not None,
        'FrequencyAnalyzer': FrequencyAnalyzer is not None,
        'StabilityValidator': StabilityValidator is not None,
        'ParametricAnalyzer': ParametricAnalyzer is not None
    }

    for module, status in modules_status.items():
        status_str = "‚úÖ OK" if status else "‚ö†Ô∏è PROBLEMA"
        print(f"   {module}: {status_str}")
        validation_results.append(('Importa√ß√£o', module, status))

    print("\n2. TESTANDO FUNCIONALIDADE B√ÅSICA...")
    print("-" * 50)

    # Teste b√°sico com sistema simples
    test_system = 1 / (s + 1)
    engine = StabilityAnalysisEngine()

    try:
        # Teste de an√°lise r√°pida
        quick_result = engine.quick_stability_check(test_system)
        quick_ok = isinstance(quick_result, dict) and 'is_stable' in quick_result
        print(f"   An√°lise R√°pida: {'‚úÖ OK' if quick_ok else '‚ö†Ô∏è PROBLEMA'}")
        validation_results.append(('Funcionalidade', 'An√°lise R√°pida', quick_ok))

        # Teste de an√°lise completa
        comprehensive_result = engine.comprehensive_analysis(test_system, show_all_steps=False)
        comprehensive_ok = comprehensive_result is not None
        print(f"   An√°lise Completa: {'‚úÖ OK' if comprehensive_ok else '‚ö†Ô∏è PROBLEMA'}")
        validation_results.append(('Funcionalidade', 'An√°lise Completa', comprehensive_ok))

    except Exception as e:
        print(f"   ‚ö†Ô∏è ERRO na funcionalidade b√°sica: {str(e)}")
        validation_results.append(('Funcionalidade', 'B√°sica', False))

    print("\n3. TESTANDO PEDAGOGIA E TRANSPAR√äNCIA...")
    print("-" * 50)

    try:
        # Verificar se o relat√≥rio pedag√≥gico funciona
        test_system = 1 / (s**2 + s + 1)
        result = engine.comprehensive_analysis(test_system, show_all_steps=True)

        if result:
            full_report = result.get_full_report()
            validation_report = result.get_cross_validation_report()

            # Verificar conte√∫do pedag√≥gico
            pedagogical_markers = ['EDUCACIONAL', 'conceito', 'f√≥rmula', 'interpreta√ß√£o']
            pedagogical_score = sum(1 for marker in pedagogical_markers
                                  if marker.lower() in full_report.lower())

            pedagogy_ok = pedagogical_score >= 2
            print(f"   Conte√∫do Pedag√≥gico: {'‚úÖ OK' if pedagogy_ok else '‚ö†Ô∏è LIMITADO'} ({pedagogical_score} elementos)")
            validation_results.append(('Pedagogia', 'Conte√∫do', pedagogy_ok))

            # Verificar valida√ß√£o cruzada
            cross_validation_ok = len(validation_report) > 50
            print(f"   Valida√ß√£o Cruzada: {'‚úÖ OK' if cross_validation_ok else '‚ö†Ô∏è LIMITADO'}")
            validation_results.append(('Pedagogia', 'Valida√ß√£o Cruzada', cross_validation_ok))

    except Exception as e:
        print(f"   ‚ö†Ô∏è ERRO na pedagogia: {str(e)}")
        validation_results.append(('Pedagogia', 'Geral', False))

    print("\n4. TESTANDO INTEGRA√á√ÉO ENTRE M√âTODOS...")
    print("-" * 50)

    try:
        # Testar valida√ß√£o cruzada com sistema conhecido
        stable_system = 1 / (s + 1)

        if StabilityValidator:
            validator = StabilityValidator()
            cross_validation = validator.validate_stability_methods(stable_system, show_steps=False)

            methods_tested = len([k for k in cross_validation.keys() if k not in ['summary', 'agreement']])
            integration_ok = methods_tested >= 2

            print(f"   M√©todos Integrados: {'‚úÖ OK' if integration_ok else '‚ö†Ô∏è LIMITADO'} ({methods_tested} m√©todos)")
            validation_results.append(('Integra√ß√£o', 'M√©todos', integration_ok))

    except Exception as e:
        print(f"   ‚ö†Ô∏è ERRO na integra√ß√£o: {str(e)}")
        validation_results.append(('Integra√ß√£o', 'Geral', False))

    print("\n5. TESTANDO CASOS ESPECIAIS...")
    print("-" * 50)

    # Teste com diferentes tipos de sistemas
    special_cases = {
        'Sistema Marginal': s**2 + 1,
        'Sistema Alta Ordem': s**5 + 2*s**4 + 3*s**3 + 4*s**2 + 5*s + 6,
        'Sistema com Zeros': (s + 1) / (s**2 + s + 1)
    }

    special_cases_ok = 0
    for case_name, case_system in special_cases.items():
        try:
            case_result = engine.quick_stability_check(case_system)
            if isinstance(case_result, dict):
                special_cases_ok += 1
                print(f"   {case_name}: ‚úÖ OK")
            else:
                print(f"   {case_name}: ‚ö†Ô∏è PROBLEMA")
        except Exception as e:
            print(f"   {case_name}: ‚ö†Ô∏è ERRO - {str(e)}")

    special_ok = special_cases_ok >= 2
    validation_results.append(('Casos Especiais', 'Geral', special_ok))

    print("\n" + "=" * 70)
    print("RESUMO DA VALIDA√á√ÉO")
    print("=" * 70)

    # Resumo por categoria
    categories = {}
    for category, component, status in validation_results:
        if category not in categories:
            categories[category] = {'total': 0, 'passed': 0}
        categories[category]['total'] += 1
        if status:
            categories[category]['passed'] += 1

    overall_score = 0
    total_tests = 0

    for category, stats in categories.items():
        passed = stats['passed']
        total = stats['total']
        percentage = (passed / total) * 100 if total > 0 else 0

        status_icon = "‚úÖ" if percentage >= 80 else "‚ö†Ô∏è" if percentage >= 60 else "‚ùå"
        print(f"{status_icon} {category}: {passed}/{total} ({percentage:.1f}%)")

        overall_score += passed
        total_tests += total

    # Score geral
    overall_percentage = (overall_score / total_tests) * 100 if total_tests > 0 else 0
    overall_icon = "‚úÖ" if overall_percentage >= 80 else "‚ö†Ô∏è" if overall_percentage >= 60 else "‚ùå"

    print("\n" + "-" * 70)
    print(f"{overall_icon} SCORE GERAL: {overall_score}/{total_tests} ({overall_percentage:.1f}%)")

    if overall_percentage >= 80:
        print("üéâ M√ìDULO 5 VALIDADO COM SUCESSO!")
        print("‚úÖ Todas as funcionalidades principais est√£o operacionais")
        print("‚úÖ Pedagogia e transpar√™ncia implementadas")
        print("‚úÖ Integra√ß√£o entre m√©todos funcionando")
    elif overall_percentage >= 60:
        print("‚ö†Ô∏è M√ìDULO 5 PARCIALMENTE FUNCIONAL")
        print("‚ÑπÔ∏è Algumas funcionalidades podem precisar de ajustes")
    else:
        print("‚ùå M√ìDULO 5 PRECISA DE CORRE√á√ïES")
        print("üîß Verificar implementa√ß√µes que falharam")

    print("=" * 70)

    return {
        'overall_score': overall_percentage,
        'detailed_results': validation_results,
        'categories': categories
    }


if __name__ == "__main__":
    run_module_validation()
