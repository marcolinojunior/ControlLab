"""
ControlLab - Projeto de Observadores
====================================

Este m√≥dulo implementa m√©todos de projeto de observadores de estado:
- Verifica√ß√£o de observabilidade
- Projeto de observadores usando a dualidade
- Observador de Luenberger
- Demonstra√ß√£o da dualidade controlador-observador

Caracter√≠sticas:
- Demonstra√ß√£o expl√≠cita da dualidade
- Explica√ß√µes step-by-step
- Projeto sistem√°tico de observadores
- An√°lise de converg√™ncia
"""

import sympy as sp
import numpy as np
from typing import List, Optional, Union, Tuple, Dict, Any
from ..core.symbolic_ss import SymbolicStateSpace
from .design_utils import ControllerResult, create_educational_content

def check_observability(ss_obj: SymbolicStateSpace,
                       show_steps: bool = True) -> Dict[str, Any]:
    """
    Verifica se o sistema √© completamente observ√°vel

    Args:
        ss_obj: Sistema em espa√ßo de estados
        show_steps: Se deve mostrar passos detalhados

    Returns:
        Dict[str, Any]: Resultado da an√°lise de observabilidade
    """
    if show_steps:
        print("üîç VERIFICA√á√ÉO DE OBSERVABILIDADE")
        print("=" * 40)
        print(f"üè≠ Sistema: ·∫ã = Ax + Bu, y = Cx + Du")
        print(f"üìê A = {ss_obj.A}")
        print(f"üìê C = {ss_obj.C}")

    A = ss_obj.A
    C = ss_obj.C
    n = A.rows  # Ordem do sistema

    # Construir matriz de observabilidade Wo = [C; CA; CA¬≤; ...; CA^(n-1)]
    if show_steps:
        print("\nüìã CONSTRU√á√ÉO DA MATRIZ DE OBSERVABILIDADE")
        print("=" * 50)
        print("Wo = [C; CA; CA¬≤; ...; CA^(n-1)]")

    Wo_blocks = [C]
    current_block = C

    for i in range(1, n):
        current_block = current_block * A
        Wo_blocks.append(current_block)

        if show_steps:
            print(f"CA^{i} = {current_block}")

    # Concatenar verticalmente
    Wo = sp.Matrix.vstack(*Wo_blocks)

    if show_steps:
        print(f"\nüìä Matriz de Observabilidade:")
        print(f"Wo = {Wo}")

    # Calcular determinante e rank
    det_Wo = Wo.det()
    rank_Wo = Wo.rank()

    # Sistema √© observ√°vel se rank(Wo) = n
    is_observable = rank_Wo == n

    if show_steps:
        print(f"\n‚úÖ AN√ÅLISE DE OBSERVABILIDADE:")
        print(f"üìê Determinante: det(Wo) = {det_Wo}")
        print(f"üìä Rank: rank(Wo) = {rank_Wo}")
        print(f"üìè Ordem do sistema: n = {n}")

        if is_observable:
            print("‚úÖ Sistema COMPLETAMENTE OBSERV√ÅVEL")
            print("üí° Todos os estados podem ser estimados")
        else:
            print("‚ùå Sistema N√ÉO completamente observ√°vel")
            print(f"‚ö†Ô∏è Apenas {rank_Wo} de {n} estados s√£o observ√°veis")

    # Conte√∫do educacional
    educational_content = [
        "üéì CONCEITO DE OBSERVABILIDADE:",
        "‚Ä¢ Um sistema √© observ√°vel se todos os estados podem ser",
        "  determinados a partir das sa√≠das e entradas medidas",
        "‚Ä¢ Crit√©rio: rank(Wo) = n (ordem do sistema)",
        "‚Ä¢ Matriz Wo = [C; CA; CA¬≤; ...; CA^(n-1)]",
        "‚Ä¢ Dual da controlabilidade: Wo = (Wc)·µÄ para sistema dual"
    ]

    return {
        'is_observable': is_observable,
        'observability_matrix': Wo,
        'rank': rank_Wo,
        'determinant': det_Wo,
        'system_order': n,
        'educational_content': educational_content
    }

def acker_observer(ss_obj: SymbolicStateSpace,
                  desired_poles: List[Union[complex, sp.Symbol]],
                  show_steps: bool = True) -> Dict[str, Any]:
    """
    Projeta observador usando F√≥rmula de Ackermann via dualidade

    Args:
        ss_obj: Sistema em espa√ßo de estados
        desired_poles: Polos desejados para o observador
        show_steps: Se deve mostrar passos detalhados

    Returns:
        Dict[str, Any]: Ganhos do observador e an√°lise
    """
    if show_steps:
        print("üéØ PROJETO DE OBSERVADOR - F√ìRMULA DE ACKERMANN")
        print("=" * 55)
        print(f"üè≠ Sistema: ·∫ã = Ax + Bu, y = Cx")
        print(f"üéØ Polos desejados para observador: {desired_poles}")

    A = ss_obj.A
    C = ss_obj.C
    n = A.rows

    # Verificar observabilidade primeiro
    observability = check_observability(ss_obj, show_steps=False)

    if not observability['is_observable']:
        error_message = (
            f"FALHA NO PROJETO DO OBSERVADOR: O sistema n√£o √© observ√°vel.\n\n"
            f"--> DIAGN√ìSTICO T√âCNICO:\n"
            f"    A matriz de observabilidade deve ter posto completo (rank={n}), mas o posto calculado foi {observability['rank']}.\n\n"
            f"--> MATRIZ DE OBSERVABILIDADE CALCULADA:\n{observability['observability_matrix']}\n\n"
            f"--> A√á√ÉO RECOMENDADA:\n"
            f"    Revise as matrizes A e C do seu modelo. Pode haver estados que n√£o afetam a sa√≠da."
        )
        raise ValueError(error_message)

    # DEMONSTRA√á√ÉO DA DUALIDADE
    if show_steps:
        print(f"\nüéì APLICA√á√ÉO DO PRINC√çPIO DA DUALIDADE")
        print("=" * 50)
        print("üìö TEORIA DA DUALIDADE:")
        print("‚Ä¢ Observador √© dual do controlador")
        print("‚Ä¢ Se (A,B) √© control√°vel ‚ü∫ (A·µÄ,C·µÄ) √© observ√°vel")
        print("‚Ä¢ Projeto: usar Ackermann no sistema dual")
        print("\nüîÑ SISTEMA DUAL:")
        print("·∫ãd = A·µÄxd + C·µÄud")

    # Criar sistema dual
    A_dual = A.T  # A·µÄ
    B_dual = C.T  # C·µÄ (B do sistema dual)

    if show_steps:
        print(f"üìê A_dual = A·µÄ = {A_dual}")
        print(f"üìê B_dual = C·µÄ = {B_dual}")

    # Criar sistema dual para usar Ackermann
    from ..core.symbolic_ss import SymbolicStateSpace
    dual_system = SymbolicStateSpace(A_dual, B_dual, sp.eye(n), sp.zeros(n, 1))

    # Aplicar Ackermann no sistema dual
    if show_steps:
        print(f"\nüîß APLICANDO ACKERMANN NO SISTEMA DUAL:")
        print("=" * 45)

    from .pole_placement import acker
    acker_result = acker(dual_system, desired_poles, show_steps)

    if not acker_result['success']:
        return acker_result

    # Ganhos do observador s√£o a transposta dos ganhos do controlador dual
    L = acker_result['gains'].T

    if show_steps:
        print(f"\n‚úÖ GANHOS DO OBSERVADOR:")
        print(f"L = K·µÄ = {L}")
        print(f"\nüîÑ Observador de Luenberger:")
        print(f"·∫ãÃÇ = AxÃÇ + Bu + L(y - CxÃÇ)")
        print(f"·∫ãÃÇ = (A - LC)xÃÇ + Bu + Ly")
        print(f"\nüìê Matriz do observador:")
        print(f"A - LC = {A - L * C}")

    # Verificar polos do observador
    A_obs = A - L * C
    char_poly_obs = A_obs.charpoly('s')

    if show_steps:
        print(f"\n‚úÖ VERIFICA√á√ÉO:")
        print(f"Polin√¥mio caracter√≠stico do observador:")
        print(f"det(sI - (A - LC)) = {char_poly_obs}")

        print(f"\nüéì DIN√ÇMICA DO ERRO DE ESTIMA√á√ÉO:")
        print(f"e = x - xÃÇ (erro de estima√ß√£o)")
        print(f"ƒó = (A - LC)e")
        print(f"Erro converge se polos de (A - LC) s√£o est√°veis")

    # Conte√∫do educacional espec√≠fico para observadores
    educational_content = [
        "üéì OBSERVADOR DE LUENBERGER:",
        "‚Ä¢ Estima estados n√£o medidos do sistema",
        "‚Ä¢ ·∫ãÃÇ = AxÃÇ + Bu + L(y - CxÃÇ)",
        "‚Ä¢ L s√£o os ganhos do observador",
        "‚Ä¢ Din√¢mica do erro: ƒó = (A - LC)e",
        "",
        "üéì PRINC√çPIO DA DUALIDADE:",
        "‚Ä¢ Observador √© dual do controlador",
        "‚Ä¢ Mesmo m√©todo (Ackermann) aplicado ao sistema dual",
        "‚Ä¢ L = K_dual^T onde K_dual √© ganho do sistema (A^T, C^T)",
        "",
        "üéì SEPARA√á√ÉO:",
        "‚Ä¢ Observador pode ser projetado independentemente",
        "‚Ä¢ Polos do observador devem ser mais r√°pidos que controlador",
        "‚Ä¢ Regra pr√°tica: polos 3-5 vezes mais r√°pidos"
    ]

    return {
        'success': True,
        'observer_gains': L,
        'observer_matrix': A_obs,
        'desired_polynomial': acker_result['desired_polynomial'],
        'observer_polynomial': char_poly_obs,
        'dual_system_result': acker_result,
        'observability': observability,
        'educational_content': educational_content
    }

def design_luenberger_observer(ss_obj: SymbolicStateSpace,
                              desired_poles: List[Union[complex, sp.Symbol]],
                              show_steps: bool = True) -> ControllerResult:
    """
    Projeta observador de Luenberger completo

    Args:
        ss_obj: Sistema em espa√ßo de estados
        desired_poles: Polos desejados para converg√™ncia do observador
        show_steps: Se deve mostrar passos

    Returns:
        ControllerResult: Observador projetado
    """
    if show_steps:
        print("üéØ PROJETO DE OBSERVADOR DE LUENBERGER")
        print("=" * 45)

    # Usar m√©todo de Ackermann via dualidade
    observer_result = acker_observer(ss_obj, desired_poles, show_steps)

    if observer_result['success']:
        L = observer_result['observer_gains']

        result = ControllerResult(controller=L)
        result.add_step("Verifica√ß√£o de observabilidade realizada")
        result.add_step("Princ√≠pio da dualidade aplicado")
        result.add_step("Sistema dual criado (A^T, C^T)")
        result.add_step("F√≥rmula de Ackermann aplicada ao sistema dual")
        result.add_step(f"Ganhos do observador: L = {L}")
        result.add_step("Observador: ·∫ãÃÇ = (A - LC)xÃÇ + Bu + Ly")

        # Adicionar conte√∫do educacional
        for note in observer_result['educational_content']:
            result.add_educational_note(note)

        result.stability_analysis = {
            'observer_matrix': observer_result['observer_matrix'],
            'desired_poles': desired_poles
        }

        return result

    else:
        result = ControllerResult(controller=None)
        result.add_step("‚ùå Falha: Sistema n√£o √© completamente observ√°vel")

        return result

class ObserverDesigner:
    """
    Classe para projeto sistem√°tico de observadores

    Fornece interface unificada para projeto de observadores
    com demonstra√ß√£o da dualidade.
    """

    def __init__(self, system: SymbolicStateSpace, show_steps: bool = True):
        """
        Inicializa o designer de observadores

        Args:
            system: Sistema em espa√ßo de estados
            show_steps: Se deve mostrar passos
        """
        self.system = system
        self.show_steps = show_steps
        self.design_history = []

    def design_observer(self,
                       desired_poles: List[Union[complex, sp.Symbol]],
                       method: str = 'ackermann') -> ControllerResult:
        """
        Projeta observador usando m√©todo especificado

        Args:
            desired_poles: Polos desejados para o observador
            method: M√©todo de projeto ('ackermann', 'pole_placement')

        Returns:
            ControllerResult: Observador projetado
        """
        if method == 'ackermann':
            return design_luenberger_observer(self.system, desired_poles, self.show_steps)
        else:
            raise ValueError(f"M√©todo '{method}' n√£o implementado")

    def analyze_observability(self) -> Dict[str, Any]:
        """Analisa observabilidade do sistema"""
        return check_observability(self.system, self.show_steps)

    def demonstrate_duality(self, controller_poles: List, observer_poles: List) -> Dict[str, Any]:
        """
        Demonstra a dualidade entre controlador e observador

        Args:
            controller_poles: Polos do controlador
            observer_poles: Polos do observador

        Returns:
            Dict[str, Any]: Demonstra√ß√£o da dualidade
        """
        if self.show_steps:
            print("üéì DEMONSTRA√á√ÉO DA DUALIDADE CONTROLADOR-OBSERVADOR")
            print("=" * 60)

        # Verificar controlabilidade
        from .pole_placement import check_controllability
        controllability = check_controllability(self.system, show_steps=False)

        # Verificar observabilidade
        observability = check_observability(self.system, show_steps=False)

        if self.show_steps:
            print(f"‚úÖ Sistema control√°vel: {controllability['is_controllable']}")
            print(f"‚úÖ Sistema observ√°vel: {observability['is_observable']}")

            print(f"\nüîÑ SISTEMA ORIGINAL:")
            print(f"A = {self.system.A}")
            print(f"B = {self.system.B}")
            print(f"C = {self.system.C}")

            print(f"\nüîÑ SISTEMA DUAL:")
            print(f"A_dual = A^T = {self.system.A.T}")
            print(f"B_dual = C^T = {self.system.C.T}")
            print(f"C_dual = B^T = {self.system.B.T}")

            print(f"\nüìä MATRIZES DE CONTROLABILIDADE E OBSERVABILIDADE:")
            print(f"Wc (controlabilidade) = {controllability['controllability_matrix']}")
            print(f"Wo (observabilidade) = {observability['observability_matrix']}")
            print(f"Rela√ß√£o: Wo = (Wc_dual)^T")

        return {
            'controllability': controllability,
            'observability': observability,
            'dual_A': self.system.A.T,
            'dual_B': self.system.C.T,
            'dual_C': self.system.B.T,
            'duality_verified': controllability['is_controllable'] == observability['is_observable']
        }
